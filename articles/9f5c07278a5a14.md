---
title: "kamalでRailsアプリケーションをEC2へデプロイする"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ruby","rails","aws","kamal","docker"]
published: false
---

kamalは, Ruby on Railsの作者として知られる,
David Heinemeier Hasson (DHH)氏によってリリースされた
WEB アプリケーションのデプロイ自動化ツールです.

めんどくさいデプロイ作業を簡単にやってくれそうなので
既存プロジェクトのRails7.1アップデートのついでに触ってみました.
復習兼,備忘録として投稿しています.
https://kamal-deploy.org/

# 完成図
下記の構成図のような環境を作成し, 
EC2へRailsアプリケーションをデプロイします.
```mermaid
graph TD
    style AWSCloud fill:none,color:#345,stroke:#345;
    style Region fill:none,color:#59d,stroke:#59d,stroke-dasharray:3;
    style VPC fill:none,color:#0a0,stroke:#0a0;
    style PublicSubnet fill:#E8F2F9,color:#07b,stroke:none;
    style PrivateSubnet fill:#E7F2E8,color:#092,stroke:none;
    style Route53 fill:#84d,color:#fff,stroke:none;
    style ALB fill:#84d,color:#fff,stroke:none;
    style EC2 fill:#e83,color:#fff,stroke:none;
    style RDS fill:#46d,color:#fff,stroke:#fff;
    style User fill:#aaa,color:#fff,stroke:#fff;

    subgraph AWSCloud[AWS Cloud]
        subgraph Region[AWS Region]
            ALB[ALB]
            subgraph VPC[VPC]
                subgraph PublicSubnet[Public Subnet]
                    EC2[EC2]
                end
                subgraph PrivateSubnet[Private Subnet]
                    RDS[RDS]
                end
            end
        end
    end

    User[User] --> Route53[Route53]
    Route53 --> ALB
    ALB --> EC2
    EC2 --> RDS
```

# AWS環境の構築
今回はubuntuのイメージを利用してEC2を作成し,PostgresqlのRDSをDBとして利用します.
ここらへんはサラッと流します
- **VPC作成**
- **EC2作成**
作成後ElasticIPでIPアドレスを固定にします.
IPを固定にする理由は, kamalhaIPアドレスを指定してデプロイを行うため,
IPアドレスが変更されると確認するのが手間だからです.
- **RDS作成**
セキュリティグループにEC2のセキュリティグループを追加
- **ALB作成**
ALBのセキュリティグループをEC2のセキュリティグループに追加
- **Route53作成**
# Railsアプリケーションの作成
```zsh
$ rails -v
Rails 7.1.0
```
```ruby
rails new my_app --api
```
今回はRails7.1のapiモードで下図テーブル構成のアプリケーションを作成しました.
Rails7.1で `rails new` すると,最初から `Dockerfile` や `bin/docker-entrypoint` , `.dockerignore` が生成されています.嬉しいですね.

https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/Dockerfile.tt

# kamalでのデプロイ
## kamalの導入

**Gemfile** にkamalを記述し,installします.
```ruby
# Gemfile
gem 'kamal', '~> 1.0.0'
```

```
$ bundle install
```

`kamal init` コマンドを実行することで `config/deploy.yml`が生成されます.
`config/deploy.yml`にデプロイ設定を記述していきます.
```zsh
$ kamal init
Created configuration file in config/deploy.yml
Created .env file
Created sample hooks in .kamal/hooks
```
`config/deploy.yml`を編集することでデプロイが可能になります.

## EC2インスタンスへのSSH接続準備
kamalがssh接続できるようにssh agentにEC2のpemを追加します
```
ssh-add /path/to/your-key.pem
```

## EC2インスタンスにdockerとcurlのinstall
```
sudo apt update
sudo apt upgrade -y
sudo apt install -y docker.io curl git
```

EC2では作成時ubuntuというユーザーが作成されます
ubuntuユーザーがsudoを使わずにDockerコマンドを実行できるように下記コマンドを実行します
```
sudo usermod -a -G docker ubuntu
```

## .envファイルの編集
kamalは`dotenv`を使用して,アプリケーションルートに存在する`.env`ファイルに設定された環境変数を自動的に読み込みます.
.envファイルに以下を記述します
- **KAMAL_REGISTRY_PASSWORD**
docker imageをpushするレジストリのパスワード
docker hubの場合tokenの利用が推奨されている
- **RAILS_MASTER_KEY**
master.keyの内容
- **DB_URL**
RDSへの接続情報

```ruby
KAMAL_REGISTRY_PASSWORD=change-this
RAILS_MASTER_KEY=master.keyの値を入力
DATABASE_URL="postgres://myuser:mypass@localhost/somedatabase"
```

## database.ymlの編集
今回はproduction環境でデプロイするので,
production環境で先程つくったRDSに接続させるようにします.

```ruby
production:
  <<: *default
  url: <%= ENV['DATABASE_URL'] %>
```

## deploy.ymlの編集
ドキュメントとdeploy.ymlのコメントをみれば分かるようになっています

- service
任意の名前を入力します
- image
コンテナのイメージ名を入力します
- servers
EC2のパブリックIPアドレスを入力します
```ruby
# Name of your application. Used to uniquely configure containers.
service: kamal-practice

# Name of the container image.
image: user/kamal-practice

# Deploy to these servers.
servers:
  - EC2IP
```

- registry
今回はdocker hubを使うのでdockerのuser名を入力します
- env
必要な環境変数をここで入力します
- ssh
ubuntuのイメージを利用してEC2を作成した場合,ubuntuを入力します

```ruby
# Credentials for your image host.
registry:
  # Specify the registry server, if you're not using Docker Hub
  # server: registry.digitalocean.com / ghcr.io / ...
  username: user

  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .env).
# Remember to run `kamal env push` after making changes!
env:
  secret:
    - RAILS_MASTER_KEY
    - DB_URL

# Use a different ssh user than root
ssh:
  user: ubuntu
```

:::details 生成されたdeploy.yml
```ruby
# Name of your application. Used to uniquely configure containers.
service: my-app

# Name of the container image.
image: user/my-app

# Deploy to these servers.
servers:
  - 192.168.0.1

# Credentials for your image host.
registry:
  # Specify the registry server, if you're not using Docker Hub
  # server: registry.digitalocean.com / ghcr.io / ...
  username: my-user

  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .env).
# Remember to run `kamal env push` after making changes!
# env:
#   clear:
#     DB_HOST: 192.168.0.2
#   secret:
#     - RAILS_MASTER_KEY

# Use a different ssh user than root
# ssh:
#   user: app

# Configure builder setup.
# builder:
#   args:
#     RUBY_VERSION: 3.2.0
#   secrets:
#     - GITHUB_TOKEN
#   remote:
#     arch: amd64
#     host: ssh://app@192.168.0.1

# Use accessory services (secrets come from .env).
# accessories:
#   db:
#     image: mysql:8.0
#     host: 192.168.0.2
#     port: 3306
#     env:
#       clear:
#         MYSQL_ROOT_HOST: '%'
#       secret:
#         - MYSQL_ROOT_PASSWORD
#     files:
#       - config/mysql/production.cnf:/etc/mysql/my.cnf
#       - db/production.sql:/docker-entrypoint-initdb.d/setup.sql
#     directories:
#       - data:/var/lib/mysql
#   redis:
#     image: redis:7.0
#     host: 192.168.0.2
#     port: 6379
#     directories:
#       - data:/data

# Configure custom arguments for Traefik
# traefik:
#   args:
#     accesslog: true
#     accesslog.format: json

# Configure a custom healthcheck (default is /up on port 3000)
# healthcheck:
#   path: /healthz
#   port: 4000

# Bridge fingerprinted assets, like JS and CSS, between versions to avoid
# hitting 404 on in-flight requests. Combines all files from new and old
# version inside the asset_path.
# asset_path: /rails/public/assets

# Configure rolling deploys by setting a wait time between batches of restarts.
# boot:
#   limit: 10 # Can also specify as a percentage of total hosts, such as "25%"
#   wait: 2

```
:::

## kamal setup
下記のコマンドを入力することでEC2へのデプロイが完了します
```ruby
kamal setup
```
このコマンドが一体なにをしてくれているのかはドキュメントに記載されています

>This will:
>1. Connect to the servers over SSH (using root by default, authenticated by your ssh key)
>2. Install Docker and curl on any server that might be missing it (using apt-get): root access is needed via ssh for this.
>3. Log into the registry both locally and remotely
>4. Build the image using the standard Dockerfile in the root of the application.
>5. Push the image to the registry.
>6. Pull the image from the registry onto the servers.
>7. Push the ENV variables from .env onto the servers.
>8. Ensure Traefik is running and accepting traffic on port 80.
>9. Ensure your app responds with 200 OK to GET /up (you must have curl installed inside your app image!).
>10. Start a new container with the version of the app that matches the current git version hash.
>11. Stop the old container running the previous version of the app.
>12. Prune unused images and stopped containers to ensure servers don’t fill up.

いろんなエラーに遭遇しましたが,サーバーにsshして実際にイメージをdocker runしてみたりして
原因を探りました
nginxのdocker imageを用意したほうがいいのかな?と思っていたのですが
docker初心者なのでtraefikの
kamalを利用してデプロイすると,traefikを利用して
pumaとtraefikの疎通も自動で行ってくれます
サーバーがport80を開けた状態になっています.
ロードバランサーやroute53の設定ミスをしていたのに気付かず,
kamalは本当にpumaのポート3000とtraefikのポート80の疎通を行ってくれてるのか...?
traefikの設定をいろいろとしないといけないのではないか,,,と思いドキュメントを片っ端から読み漁ったりしたので
1日くらいは詰まってしまいましたが
瞬時にデプロイしてくれてとてもですね
awsコンソールでポチポチサーバーを作成したり,DBを作成したりするのは若干面倒なので
terraformなどで自動化したりしたほうがいいようなきもします

# ロードバランサーで振り分ける

- コマンドの説明もちょっとする
-  config.assume_ssl = trueを疎通させないとだめだよ
- ログをみるとやたらにヘルスチェックされていて邪魔くさい
- docker inspectでdockerの設定がどうなっているかみる
```
  "Healthcheck": {
                "Test": [
                    "CMD-SHELL",
                    "(curl -f http://localhost:3000/up || exit 1) && (stat /tmp/kamal-cord/cord > /dev/null || exit 1)"
                ],
                "Interval": 1000000000
            },
```
こうなっている
```
Ensure app can pass healthcheck...
  INFO [02be2305] Running docker run --detach --name healthcheck-kamal-practice-HEAD_uncommitted_1a96b4d1f65e791d --publish 3999:3000 --label service=healthcheck-kamal-practice -e KAMAL_CONTAINER_NAME="healthcheck-kamal-practice" --env-file .kamal/env/roles/kamal-practice-web.env --health-cmd "curl -f http://localhost:3000/up || exit 1" --health-interval "1s" onikukirai/kamal-practice:HEAD_uncommitted_1a96b4d1f65e791d on 35.78.76.96
```

ここで1sごとにhealthcheckするようにされている
```
healthcheck:
  path: /healthz
  port: 4000
  max_attempts: 7
  interval: 20s
```
1時間とかにしたかったのだが
```
Releasing the deploy lock...
  Finished all in 54.2 seconds
  ERROR (Kamal::Cli::Healthcheck::Poller::HealthcheckError): Exception while executing on host 13.230.17.150: container not ready (starting)
```
  healthcheckの結果をまっているのでintervalを長くしすぎるとデプロイが失敗したとみなされてしまうみたい

  20sが最大でした